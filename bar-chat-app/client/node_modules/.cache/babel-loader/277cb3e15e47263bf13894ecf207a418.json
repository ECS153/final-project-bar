{"ast":null,"code":"var sha3 = require(\"crypto-js/sha3\");\n\nvar pkgVersion = require(\"./package.json\").version;\n\nvar Ajv = require(\"ajv\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\n\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\n\nvar abiSchema = require(\"./spec/abi.spec.json\");\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\n\n\nvar properties = {\n  \"contractName\": {\n    \"sources\": [\"contractName\", \"contract_name\"]\n  },\n  \"abi\": {\n    \"sources\": [\"abi\", \"interface\"],\n    \"transform\": function (value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (e) {\n          value = undefined;\n        }\n      }\n\n      return value;\n    }\n  },\n  \"bytecode\": {\n    \"sources\": [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    \"transform\": function (value) {\n      if (value && value.indexOf(\"0x\") != 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  \"deployedBytecode\": {\n    \"sources\": [\"deployedBytecode\", \"runtimeBytecode\", \"evm.deployedBytecode.object\"],\n    \"transform\": function (value) {\n      if (value && value.indexOf(\"0x\") != 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  \"sourceMap\": {\n    \"sources\": [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  \"deployedSourceMap\": {\n    \"sources\": [\"deployedSourceMap\", \"srcmapRuntime\", \"evm.deployedBytecode.sourceMap\"]\n  },\n  \"source\": {},\n  \"sourcePath\": {},\n  \"ast\": {},\n  \"legacyAST\": {\n    \"transform\": function (value, obj) {\n      var schemaVersion = obj.schemaVersion || \"0.0.0\"; // legacyAST introduced in v2.0.0\n\n      if (schemaVersion[0] < 2) {\n        return obj.ast;\n      } else {\n        return value;\n      }\n    }\n  },\n  \"compiler\": {},\n  \"networks\": {\n    \"transform\": function (value) {\n      if (value === undefined) {\n        value = {};\n      }\n\n      return value;\n    }\n  },\n  \"schemaVersion\": {\n    \"sources\": [\"schemaVersion\", \"schema_version\"]\n  },\n  \"updatedAt\": {\n    \"sources\": [\"updatedAt\", \"updated_at\"],\n    \"transform\": function (value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n\n      return value;\n    }\n  }\n};\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\n\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function (x) {\n      return x;\n    };\n  }\n\n  return function (obj) {\n    try {\n      return transform(obj[key]);\n    } catch (e) {\n      return undefined;\n    }\n  };\n}\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\n\n\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function (obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  };\n} // Schema module\n//\n\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function (contractObj) {\n    var ajv = new Ajv({\n      useDefaults: true\n    });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      throw ajv.errors;\n    }\n  },\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function (objDirty, options) {\n    options = options || {};\n    var normalized = {}; // iterate over each property\n\n    Object.keys(properties).forEach(function (key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n\n      var sources = property.sources || [key]; // iterate over sources until value is defined or end of list met\n\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i]; // string refers to path to value in objDirty, split and chain\n        // getters\n\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function (k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        } // source should be a function that takes the objDirty and returns\n        // value or undefined\n\n\n        value = source(objDirty);\n      } // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n\n\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      } // add resulting (possibly undefined) to normalized obj\n\n\n      normalized[key] = value;\n    }); // Copy x- options\n\n    Object.keys(objDirty).forEach(function (key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    }); // update schema version\n\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized;\n  }\n};\nmodule.exports = TruffleContractSchema;","map":{"version":3,"sources":["/Users/vsiow/Documents/UCD/S2020/final-project-bar/bar-chat-app/client/node_modules/truffle-contract-schema/index.js"],"names":["sha3","require","pkgVersion","version","Ajv","contractObjectSchema","networkObjectSchema","abiSchema","properties","value","JSON","parse","e","undefined","indexOf","obj","schemaVersion","ast","Date","toISOString","getter","key","transform","x","chain","getters","Array","prototype","slice","call","arguments","reduce","cur","get","TruffleContractSchema","validate","contractObj","ajv","useDefaults","addSchema","errors","normalize","objDirty","options","normalized","Object","keys","forEach","property","sources","i","length","source","traversals","split","map","k","apply","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,gBAAD,CAAlB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,gBAAD,CAAP,CAA0BE,OAA3C;;AACA,IAAIC,GAAG,GAAGH,OAAO,CAAC,KAAD,CAAjB;;AAEA,IAAII,oBAAoB,GAAGJ,OAAO,CAAC,kCAAD,CAAlC;;AACA,IAAIK,mBAAmB,GAAGL,OAAO,CAAC,iCAAD,CAAjC;;AACA,IAAIM,SAAS,GAAGN,OAAO,CAAC,sBAAD,CAAvB;AAGA;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,IAAIO,UAAU,GAAG;AACf,kBAAgB;AACd,eAAW,CAAC,cAAD,EAAiB,eAAjB;AADG,GADD;AAIf,SAAO;AACL,eAAW,CAAC,KAAD,EAAQ,WAAR,CADN;AAEL,iBAAa,UAASC,KAAT,EAAgB;AAC3B,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAI;AACFA,UAAAA,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWF,KAAX,CAAR;AACD,SAFD,CAEE,OAAOG,CAAP,EAAU;AACVH,UAAAA,KAAK,GAAGI,SAAR;AACD;AACF;;AACD,aAAOJ,KAAP;AACD;AAXI,GAJQ;AAiBf,cAAY;AACV,eAAW,CACT,UADS,EACG,QADH,EACa,iBADb,EACgC,qBADhC,CADD;AAIV,iBAAa,UAASA,KAAT,EAAgB;AAC3B,UAAIA,KAAK,IAAIA,KAAK,CAACK,OAAN,CAAc,IAAd,KAAuB,CAApC,EAAuC;AACrCL,QAAAA,KAAK,GAAG,OAAOA,KAAf;AACD;;AACD,aAAOA,KAAP;AACD;AATS,GAjBG;AA4Bf,sBAAoB;AAClB,eAAW,CACT,kBADS,EACW,iBADX,EAC8B,6BAD9B,CADO;AAIlB,iBAAa,UAASA,KAAT,EAAgB;AAC3B,UAAIA,KAAK,IAAIA,KAAK,CAACK,OAAN,CAAc,IAAd,KAAuB,CAApC,EAAuC;AACrCL,QAAAA,KAAK,GAAG,OAAOA,KAAf;AACD;;AACD,aAAOA,KAAP;AACD;AATiB,GA5BL;AAuCf,eAAa;AACX,eAAW,CAAC,WAAD,EAAc,QAAd,EAAwB,wBAAxB;AADA,GAvCE;AA0Cf,uBAAqB;AACnB,eAAW,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,gCAAvC;AADQ,GA1CN;AA6Cf,YAAU,EA7CK;AA8Cf,gBAAc,EA9CC;AA+Cf,SAAO,EA/CQ;AAgDf,eAAa;AACX,iBAAa,UAASA,KAAT,EAAgBM,GAAhB,EAAqB;AAChC,UAAIC,aAAa,GAAGD,GAAG,CAACC,aAAJ,IAAqB,OAAzC,CADgC,CAGhC;;AACA,UAAIA,aAAa,CAAC,CAAD,CAAb,GAAmB,CAAvB,EAA0B;AACxB,eAAOD,GAAG,CAACE,GAAX;AACD,OAFD,MAEO;AACL,eAAOR,KAAP;AACD;AACF;AAVU,GAhDE;AA4Df,cAAY,EA5DG;AA6Df,cAAY;AACV,iBAAa,UAASA,KAAT,EAAgB;AAC3B,UAAIA,KAAK,KAAKI,SAAd,EAAyB;AACvBJ,QAAAA,KAAK,GAAG,EAAR;AACD;;AACD,aAAOA,KAAP;AACD;AANS,GA7DG;AAqEf,mBAAiB;AACf,eAAW,CAAC,eAAD,EAAkB,gBAAlB;AADI,GArEF;AAwEf,eAAa;AACX,eAAW,CAAC,WAAD,EAAc,YAAd,CADA;AAEX,iBAAa,UAASA,KAAT,EAAgB;AAC3B,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,QAAAA,KAAK,GAAG,IAAIS,IAAJ,CAAST,KAAT,EAAgBU,WAAhB,EAAR;AACD;;AACD,aAAOV,KAAP;AACD;AAPU;AAxEE,CAAjB;AAoFA;;;;;;;AAMA,SAASW,MAAT,CAAgBC,GAAhB,EAAqBC,SAArB,EAAgC;AAC9B,MAAIA,SAAS,KAAKT,SAAlB,EAA6B;AAC3BS,IAAAA,SAAS,GAAG,UAASC,CAAT,EAAY;AAAE,aAAOA,CAAP;AAAU,KAApC;AACD;;AAED,SAAO,UAASR,GAAT,EAAc;AACnB,QAAI;AACF,aAAOO,SAAS,CAACP,GAAG,CAACM,GAAD,CAAJ,CAAhB;AACD,KAFD,CAEE,OAAOT,CAAP,EAAU;AACV,aAAOC,SAAP;AACD;AACF,GAND;AAOD;AAGD;;;;;;;;;;;;AAUA,SAASW,KAAT,GAAiB;AACf,MAAIC,OAAO,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAd;AACA,SAAO,UAASf,GAAT,EAAc;AACnB,WAAOU,OAAO,CAACM,MAAR,CAAe,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AACxC,aAAOA,GAAG,CAACD,GAAD,CAAV;AACD,KAFM,EAEJjB,GAFI,CAAP;AAGD,GAJD;AAKD,C,CAGD;AACA;;;AAEA,IAAImB,qBAAqB,GAAG;AAC1B;AACA;AACA;AACAC,EAAAA,QAAQ,EAAE,UAASC,WAAT,EAAsB;AAC9B,QAAIC,GAAG,GAAG,IAAIjC,GAAJ,CAAQ;AAAEkC,MAAAA,WAAW,EAAE;AAAf,KAAR,CAAV;AACAD,IAAAA,GAAG,CAACE,SAAJ,CAAchC,SAAd;AACA8B,IAAAA,GAAG,CAACE,SAAJ,CAAcjC,mBAAd;AACA+B,IAAAA,GAAG,CAACE,SAAJ,CAAclC,oBAAd;;AACA,QAAIgC,GAAG,CAACF,QAAJ,CAAa,2BAAb,EAA0CC,WAA1C,CAAJ,EAA4D;AAC1D,aAAOA,WAAP;AACD,KAFD,MAEO;AACL,YAAMC,GAAG,CAACG,MAAV;AACD;AACF,GAdyB;AAgB1B;AACA;AACAC,EAAAA,SAAS,EAAE,UAASC,QAAT,EAAmBC,OAAnB,EAA4B;AACrCA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAIC,UAAU,GAAG,EAAjB,CAFqC,CAIrC;;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAYtC,UAAZ,EAAwBuC,OAAxB,CAAgC,UAAS1B,GAAT,EAAc;AAC5C,UAAI2B,QAAQ,GAAGxC,UAAU,CAACa,GAAD,CAAzB;AACA,UAAIZ,KAAJ,CAF4C,CAEhC;AAEZ;AACA;;AACA,UAAIwC,OAAO,GAAGD,QAAQ,CAACC,OAAT,IAAoB,CAAC5B,GAAD,CAAlC,CAN4C,CAQ5C;;AACA,WAAK,IAAI6B,CAAC,GAAG,CAAb,EAAgBzC,KAAK,KAAKI,SAAV,IAAuBqC,CAAC,GAAGD,OAAO,CAACE,MAAnD,EAA2DD,CAAC,EAA5D,EAAgE;AAC9D,YAAIE,MAAM,GAAGH,OAAO,CAACC,CAAD,CAApB,CAD8D,CAE9D;AACA;;AACA,YAAI,OAAOE,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,cAAIC,UAAU,GAAGD,MAAM,CAACE,KAAP,CAAa,GAAb,EACdC,GADc,CACV,UAASC,CAAT,EAAY;AAAE,mBAAOpC,MAAM,CAACoC,CAAD,CAAb;AAAkB,WADtB,CAAjB;AAEAJ,UAAAA,MAAM,GAAG5B,KAAK,CAACiC,KAAN,CAAY,IAAZ,EAAkBJ,UAAlB,CAAT;AACD,SAR6D,CAU9D;AACA;;;AACA5C,QAAAA,KAAK,GAAG2C,MAAM,CAACV,QAAD,CAAd;AACD,OAtB2C,CAwB5C;AACA;;;AACA,UAAIM,QAAQ,CAAC1B,SAAb,EAAwB;AACtBb,QAAAA,KAAK,GAAGuC,QAAQ,CAAC1B,SAAT,CAAmBb,KAAnB,EAA0BiC,QAA1B,CAAR;AACD,OA5B2C,CA8B5C;;;AACAE,MAAAA,UAAU,CAACvB,GAAD,CAAV,GAAkBZ,KAAlB;AACD,KAhCD,EALqC,CAuCrC;;AACAoC,IAAAA,MAAM,CAACC,IAAP,CAAYJ,QAAZ,EAAsBK,OAAtB,CAA8B,UAAS1B,GAAT,EAAc;AAC1C,UAAIA,GAAG,CAACP,OAAJ,CAAY,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B8B,QAAAA,UAAU,CAACvB,GAAD,CAAV,GAAkBD,MAAM,CAACC,GAAD,CAAN,CAAYqB,QAAZ,CAAlB;AACD;AACF,KAJD,EAxCqC,CA8CrC;;AACAE,IAAAA,UAAU,CAAC5B,aAAX,GAA2Bd,UAA3B;;AAEA,QAAIyC,OAAO,CAACR,QAAZ,EAAsB;AACpB,WAAKA,QAAL,CAAcS,UAAd;AACD;;AAED,WAAOA,UAAP;AACD;AAxEyB,CAA5B;AA2EAc,MAAM,CAACC,OAAP,GAAiBzB,qBAAjB","sourcesContent":["var sha3 = require(\"crypto-js/sha3\");\nvar pkgVersion = require(\"./package.json\").version;\nvar Ajv = require(\"ajv\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\nvar abiSchema = require(\"./spec/abi.spec.json\");\n\n\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\nvar properties = {\n  \"contractName\": {\n    \"sources\": [\"contractName\", \"contract_name\"]\n  },\n  \"abi\": {\n    \"sources\": [\"abi\", \"interface\"],\n    \"transform\": function(value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value)\n        } catch (e) {\n          value = undefined;\n        }\n      }\n      return value;\n    }\n  },\n  \"bytecode\": {\n    \"sources\": [\n      \"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"\n    ],\n    \"transform\": function(value) {\n      if (value && value.indexOf(\"0x\") != 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  \"deployedBytecode\": {\n    \"sources\": [\n      \"deployedBytecode\", \"runtimeBytecode\", \"evm.deployedBytecode.object\"\n    ],\n    \"transform\": function(value) {\n      if (value && value.indexOf(\"0x\") != 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  \"sourceMap\": {\n    \"sources\": [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  \"deployedSourceMap\": {\n    \"sources\": [\"deployedSourceMap\", \"srcmapRuntime\", \"evm.deployedBytecode.sourceMap\"]\n  },\n  \"source\": {},\n  \"sourcePath\": {},\n  \"ast\": {},\n  \"legacyAST\": {\n    \"transform\": function(value, obj) {\n      var schemaVersion = obj.schemaVersion || \"0.0.0\";\n\n      // legacyAST introduced in v2.0.0\n      if (schemaVersion[0] < 2) {\n        return obj.ast;\n      } else {\n        return value\n      }\n    }\n  },\n  \"compiler\": {},\n  \"networks\": {\n    \"transform\": function(value) {\n      if (value === undefined) {\n        value = {}\n      }\n      return value;\n    }\n  },\n  \"schemaVersion\": {\n    \"sources\": [\"schemaVersion\", \"schema_version\"]\n  },\n  \"updatedAt\": {\n    \"sources\": [\"updatedAt\", \"updated_at\"],\n    \"transform\": function(value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n      return value;\n    }\n  }\n};\n\n\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function(x) { return x };\n  }\n\n  return function(obj) {\n    try {\n      return transform(obj[key]);\n    } catch (e) {\n      return undefined;\n    }\n  }\n}\n\n\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function(obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  }\n}\n\n\n// Schema module\n//\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function(contractObj) {\n    var ajv = new Ajv({ useDefaults: true });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      throw ajv.errors;\n    }\n  },\n\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function(objDirty, options) {\n    options = options || {};\n    var normalized = {};\n\n    // iterate over each property\n    Object.keys(properties).forEach(function(key) {\n      var property = properties[key];\n      var value;  // normalized value || undefined\n\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n      var sources = property.sources || [key];\n\n      // iterate over sources until value is defined or end of list met\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i];\n        // string refers to path to value in objDirty, split and chain\n        // getters\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\")\n            .map(function(k) { return getter(k) });\n          source = chain.apply(null, traversals);\n        }\n\n        // source should be a function that takes the objDirty and returns\n        // value or undefined\n        value = source(objDirty);\n      }\n\n      // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      }\n\n      // add resulting (possibly undefined) to normalized obj\n      normalized[key] = value;\n    });\n\n    // Copy x- options\n    Object.keys(objDirty).forEach(function(key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    });\n\n    // update schema version\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized\n  }\n};\n\nmodule.exports = TruffleContractSchema;\n"]},"metadata":{},"sourceType":"script"}