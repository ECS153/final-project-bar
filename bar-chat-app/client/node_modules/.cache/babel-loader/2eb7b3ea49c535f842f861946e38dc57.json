{"ast":null,"code":"var Blockchain = {\n  getBlockByNumber: function (blockNumber, provider, callback) {\n    var params = [blockNumber, true];\n    provider.sendAsync({\n      jsonrpc: '2.0',\n      method: 'eth_getBlockByNumber',\n      params: params,\n      id: Date.now()\n    }, callback);\n  },\n  getBlockByHash: function (blockHash, provider, callback) {\n    var params = [blockHash, true];\n    provider.sendAsync({\n      jsonrpc: '2.0',\n      method: 'eth_getBlockByHash',\n      params: params,\n      id: Date.now()\n    }, callback);\n  },\n  parse: function (uri) {\n    var parsed = {};\n    if (uri.indexOf(\"blockchain://\") != 0) return parsed;\n    uri = uri.replace(\"blockchain://\", \"\");\n    var pieces = uri.split(\"/block/\");\n    parsed.genesis_hash = \"0x\" + pieces[0];\n    parsed.block_hash = \"0x\" + pieces[1];\n    return parsed;\n  },\n  asURI: function (provider, callback) {\n    var self = this;\n    var genesis;\n    self.getBlockByNumber(\"0x0\", provider, function (err, response) {\n      if (err) return callback(err);\n      genesis = response.result;\n      self.getBlockByNumber(\"latest\", provider, function (err, response) {\n        if (err) return callback(err);\n        latest = response.result;\n        var url = \"blockchain://\" + genesis.hash.replace(\"0x\", \"\") + \"/block/\" + latest.hash.replace(\"0x\", \"\");\n        callback(null, url);\n      });\n    });\n  },\n  matches: function (uri, provider, callback) {\n    var self = this;\n    uri = self.parse(uri);\n    var expected_genesis = uri.genesis_hash;\n    var expected_block = uri.block_hash;\n    self.getBlockByNumber(\"0x0\", provider, function (err, response) {\n      if (err) return callback(err);\n      var block = response.result;\n      if (block.hash != expected_genesis) return callback(null, false);\n      self.getBlockByHash(expected_block, provider, function (err, response) {\n        // Treat an error as if the block didn't exist. This is because\n        // some clients respond differently.\n        var block = response.result;\n\n        if (err || block == null) {\n          return callback(null, false);\n        }\n\n        callback(null, true);\n      });\n    });\n  }\n};\nmodule.exports = Blockchain;","map":{"version":3,"sources":["/Users/vsiow/Documents/UCD/S2020/final-project-bar/bar-chat-app/client/src/eth-bar/node_modules/truffle-blockchain-utils/index.js"],"names":["Blockchain","getBlockByNumber","blockNumber","provider","callback","params","sendAsync","jsonrpc","method","id","Date","now","getBlockByHash","blockHash","parse","uri","parsed","indexOf","replace","pieces","split","genesis_hash","block_hash","asURI","self","genesis","err","response","result","latest","url","hash","matches","expected_genesis","expected_block","block","module","exports"],"mappings":"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","sourcesContent":["var Blockchain = {\n\n  getBlockByNumber: function(blockNumber, provider, callback){\n    var params = [blockNumber, true];\n    provider.sendAsync({\n      jsonrpc: '2.0',\n      method: 'eth_getBlockByNumber',\n      params: params,\n      id: Date.now(),\n    }, callback)\n  },\n\n  getBlockByHash: function(blockHash, provider, callback){\n    var params = [blockHash, true];\n    provider.sendAsync({\n      jsonrpc: '2.0',\n      method: 'eth_getBlockByHash',\n      params: params,\n      id: Date.now(),\n    }, callback)\n  },\n\n  parse: function(uri) {\n    var parsed = {};\n    if (uri.indexOf(\"blockchain://\") != 0) return parsed;\n\n    uri = uri.replace(\"blockchain://\", \"\");\n\n    var pieces = uri.split(\"/block/\");\n\n    parsed.genesis_hash = \"0x\" + pieces[0];\n    parsed.block_hash = \"0x\" + pieces[1];\n\n    return parsed;\n  },\n\n  asURI: function(provider, callback) {\n    var self = this;\n    var genesis;\n\n    self.getBlockByNumber(\"0x0\", provider, function(err, response) {\n      if (err) return callback(err);\n      genesis = response.result;\n\n      self.getBlockByNumber(\"latest\", provider, function(err, response) {\n        if (err) return callback(err);\n        latest = response.result;\n        var url = \"blockchain://\" + genesis.hash.replace(\"0x\", \"\") + \"/block/\" + latest.hash.replace(\"0x\", \"\");\n        callback(null, url);\n      });\n    });\n  },\n\n  matches: function(uri, provider, callback) {\n    var self = this;\n    uri = self.parse(uri);\n\n    var expected_genesis = uri.genesis_hash;\n    var expected_block = uri.block_hash;\n\n    self.getBlockByNumber(\"0x0\", provider, function(err, response) {\n      if (err) return callback(err);\n      var block = response.result;\n      if (block.hash != expected_genesis) return callback(null, false);\n\n      self.getBlockByHash(expected_block, provider, function(err, response) {\n        // Treat an error as if the block didn't exist. This is because\n        // some clients respond differently.\n        var block = response.result;\n        if (err || block == null) {\n          return callback(null, false);\n        }\n\n        callback(null, true);\n      });\n    });\n  }\n};\n\nmodule.exports = Blockchain;\n"]},"metadata":{},"sourceType":"module"}