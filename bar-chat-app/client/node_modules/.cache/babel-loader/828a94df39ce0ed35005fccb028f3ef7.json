{"ast":null,"code":"'use strict';\n/* eslint-disable */\n\nvar utils = require('./utils/index.js');\n\nvar uint256Coder = utils.uint256Coder;\nvar coderBoolean = utils.coderBoolean;\nvar coderFixedBytes = utils.coderFixedBytes;\nvar coderAddress = utils.coderAddress;\nvar coderDynamicBytes = utils.coderDynamicBytes;\nvar coderString = utils.coderString;\nvar coderArray = utils.coderArray;\nvar paramTypePart = utils.paramTypePart;\nvar getParamCoder = utils.getParamCoder;\n\nfunction Result() {}\n\nfunction encodeParams(types, values) {\n  if (types.length !== values.length) {\n    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, types length ' + types.length + ' should be ' + values.length);\n  }\n\n  var parts = [];\n  types.forEach(function (type, index) {\n    var coder = getParamCoder(type);\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n\n  function alignSize(size) {\n    return parseInt(32 * Math.ceil(size / 32));\n  }\n\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Buffer(staticSize + dynamicSize);\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      uint256Coder.encode(dynamicOffset).copy(data, offset);\n      offset += 32;\n      part.value.copy(data, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      part.value.copy(data, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return '0x' + data.toString('hex');\n} // decode bytecode data from output names and types\n\n\nfunction decodeParams(names, types, data) {\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    data = types;\n    types = names;\n    names = [];\n  }\n\n  data = utils.hexOrBuffer(data);\n  var values = new Result();\n  var offset = 0;\n  types.forEach(function (type, index) {\n    var coder = getParamCoder(type);\n\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, dynamicOffset.value.toNumber());\n      offset += dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n      offset += result.consumed;\n    }\n\n    values[index] = result.value;\n\n    if (names[index]) {\n      values[names[index]] = result.value;\n    }\n  });\n  return values;\n} // encode method ABI object with values in an array, output bytecode\n\n\nfunction encodeMethod(method, values) {\n  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';\n  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');\n  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);\n  return '' + signatureEncoded + paramsEncoded;\n} // decode method data bytecode, from method ABI object\n\n\nfunction decodeMethod(method, data) {\n  var outputNames = utils.getKeys(method.outputs, 'name', true);\n  var outputTypes = utils.getKeys(method.outputs, 'type');\n  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));\n} // decode method data bytecode, from method ABI object\n\n\nfunction encodeEvent(eventObject, values) {\n  return encodeMethod(eventObject, values);\n} // decode method data bytecode, from method ABI object\n\n\nfunction decodeEvent(eventObject, data) {\n  var inputNames = utils.getKeys(eventObject.inputs, 'name', true);\n  var inputTypes = utils.getKeys(eventObject.inputs, 'type');\n  return decodeParams(inputNames, inputTypes, utils.hexOrBuffer(data));\n}\n\nmodule.exports = {\n  encodeParams: encodeParams,\n  decodeParams: decodeParams,\n  encodeMethod: encodeMethod,\n  decodeMethod: decodeMethod,\n  encodeEvent: encodeEvent,\n  decodeEvent: decodeEvent\n};","map":{"version":3,"sources":["/Users/vsiow/Documents/UCD/S2020/final-project-bar/bar-chat-app/client/node_modules/ethjs-abi/lib/index.js"],"names":["utils","require","uint256Coder","coderBoolean","coderFixedBytes","coderAddress","coderDynamicBytes","coderString","coderArray","paramTypePart","getParamCoder","Result","encodeParams","types","values","length","Error","parts","forEach","type","index","coder","push","dynamic","value","encode","alignSize","size","parseInt","Math","ceil","staticSize","dynamicSize","part","offset","dynamicOffset","data","Buffer","copy","toString","decodeParams","names","arguments","hexOrBuffer","decode","result","toNumber","consumed","encodeMethod","method","signature","name","getKeys","inputs","join","signatureEncoded","keccak256","slice","paramsEncoded","substring","decodeMethod","outputNames","outputs","outputTypes","encodeEvent","eventObject","decodeEvent","inputNames","inputTypes","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable */\n\nvar utils = require('./utils/index.js');\nvar uint256Coder = utils.uint256Coder;\nvar coderBoolean = utils.coderBoolean;\nvar coderFixedBytes = utils.coderFixedBytes;\nvar coderAddress = utils.coderAddress;\nvar coderDynamicBytes = utils.coderDynamicBytes;\nvar coderString = utils.coderString;\nvar coderArray = utils.coderArray;\nvar paramTypePart = utils.paramTypePart;\nvar getParamCoder = utils.getParamCoder;\n\nfunction Result() {}\n\nfunction encodeParams(types, values) {\n  if (types.length !== values.length) {\n    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, types length ' + types.length + ' should be ' + values.length);\n  }\n\n  var parts = [];\n\n  types.forEach(function (type, index) {\n    var coder = getParamCoder(type);\n    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n  });\n\n  function alignSize(size) {\n    return parseInt(32 * Math.ceil(size / 32));\n  }\n\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Buffer(staticSize + dynamicSize);\n\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      uint256Coder.encode(dynamicOffset).copy(data, offset);\n      offset += 32;\n\n      part.value.copy(data, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      part.value.copy(data, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n\n  return '0x' + data.toString('hex');\n}\n\n// decode bytecode data from output names and types\nfunction decodeParams(names, types, data) {\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    data = types;\n    types = names;\n    names = [];\n  }\n\n  data = utils.hexOrBuffer(data);\n  var values = new Result();\n\n  var offset = 0;\n  types.forEach(function (type, index) {\n    var coder = getParamCoder(type);\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, dynamicOffset.value.toNumber());\n      offset += dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n      offset += result.consumed;\n    }\n    values[index] = result.value;\n    if (names[index]) {\n      values[names[index]] = result.value;\n    }\n  });\n  return values;\n}\n\n// encode method ABI object with values in an array, output bytecode\nfunction encodeMethod(method, values) {\n  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';\n  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');\n  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);\n\n  return '' + signatureEncoded + paramsEncoded;\n}\n\n// decode method data bytecode, from method ABI object\nfunction decodeMethod(method, data) {\n  var outputNames = utils.getKeys(method.outputs, 'name', true);\n  var outputTypes = utils.getKeys(method.outputs, 'type');\n\n  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));\n}\n\n// decode method data bytecode, from method ABI object\nfunction encodeEvent(eventObject, values) {\n  return encodeMethod(eventObject, values);\n}\n\n// decode method data bytecode, from method ABI object\nfunction decodeEvent(eventObject, data) {\n  var inputNames = utils.getKeys(eventObject.inputs, 'name', true);\n  var inputTypes = utils.getKeys(eventObject.inputs, 'type');\n\n  return decodeParams(inputNames, inputTypes, utils.hexOrBuffer(data));\n}\n\nmodule.exports = {\n  encodeParams: encodeParams,\n  decodeParams: decodeParams,\n  encodeMethod: encodeMethod,\n  decodeMethod: decodeMethod,\n  encodeEvent: encodeEvent,\n  decodeEvent: decodeEvent\n};"]},"metadata":{},"sourceType":"script"}